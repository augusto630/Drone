#include "binding.h"
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <string>

using v8::FunctionTemplate;
using namespace std::chrono;

NAN_METHOD(GetAttitude) {
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  Nan::Set(obj, Nan::New("yaw").ToLocalChecked(), Nan::New(data_out[0]));
  Nan::Set(obj, Nan::New("pitch").ToLocalChecked(), Nan::New(data_out[1]));
  Nan::Set(obj, Nan::New("roll").ToLocalChecked(), Nan::New(data_out[2]));
  info.GetReturnValue().Set(obj);
}

NAN_METHOD(GetRotation) {
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  Nan::Set(obj, Nan::New("yaw").ToLocalChecked(), Nan::New(data_out[3]));
  Nan::Set(obj, Nan::New("pitch").ToLocalChecked(), Nan::New(data_out[4]));
  Nan::Set(obj, Nan::New("roll").ToLocalChecked(), Nan::New(data_out[5]));
  info.GetReturnValue().Set(obj);
}

NAN_METHOD(GetRawMotion6) {
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  Nan::Set(obj, Nan::New("gyro_x").ToLocalChecked(), Nan::New(data_out[0]));
  Nan::Set(obj, Nan::New("gyro_y").ToLocalChecked(), Nan::New(data_out[1]));
  Nan::Set(obj, Nan::New("gyro_z").ToLocalChecked(), Nan::New(data_out[2]));
  Nan::Set(obj, Nan::New("accel_x").ToLocalChecked(), Nan::New(data_out[3]));
  Nan::Set(obj, Nan::New("accel_y").ToLocalChecked(), Nan::New(data_out[4]));
  Nan::Set(obj, Nan::New("accel_z").ToLocalChecked(), Nan::New(data_out[5]));
  info.GetReturnValue().Set(obj);
}

NAN_METHOD(Initialize) {
  raw_initialized = false;
  
  if (!initMPU()) {
    info.GetReturnValue().Set(false);
    return;
  }

  if (pthread_create(&readThread, NULL, readFromFIFO, &data_out)) {
    fprintf(stderr, "Error creating thread\n");
    info.GetReturnValue().Set(false);
  } else {
    info.GetReturnValue().Set(true);
  }
}

NAN_METHOD(InitializeRaw) {
  raw_initialized = true;

  if (!initMPU()) {
    info.GetReturnValue().Set(false);
    return;
  }

  if (pthread_create(&readThread, NULL, readFromFIFO, &data_out)) {
    fprintf(stderr, "Error creating thread\n");
    info.GetReturnValue().Set(false);
  } else {
    info.GetReturnValue().Set(true);
  }
}

NAN_METHOD(Calibrate) {
  if(initCalibration()){
    info.GetReturnValue().Set(true);
  }else{
    info.GetReturnValue().Set(false);
  }
}

int16_t off_ax = 0, off_ay= 0, off_az= 0;
int16_t off_gx = 0, off_gy= 0, off_gz= 0;

bool initMPU() {
  // initialize device
  printf("Initializing I2C devices...\n");
  mpu.initialize();

  printf("Setting calibration...\n");

  std::ifstream in("calibration.txt");
  in >> off_ax >> off_ay >> off_az >> off_gx >> off_gy >> off_gz;
  in.close();

  printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);

  // verify connection
  printf("Testing device connections...\n");
  printf(mpu.testConnection() ? "MPU6050 connection successful\n" : "MPU6050 connection failed\n");

  if(!raw_initialized){
    printf("Initializing DMP...\n");
    devStatus = mpu.dmpInitialize();

    printf("Initialized at fifo rate of: %d.\n", mpu.dmpGetFIFORate());
    printf("Initialized at sample frequency of: %d.\n", mpu.dmpGetSampleFrequency());
  }

  mpu.setXAccelOffset(off_ax);
  mpu.setYAccelOffset(off_ay);
  mpu.setZAccelOffset(off_az);
  mpu.setXGyroOffset(off_gx);
  mpu.setYGyroOffset(off_gy);
  mpu.setZGyroOffset(off_gz);

  // make sure it worked (returns 0 if so)
  if (devStatus == 0) {   

    // If raw, ignore dmp
    if(raw_initialized){
      return true;
    }

    // turn on the DMP, now that it's ready
    printf("Enabling DMP...\n");
    mpu.setDMPEnabled(true);

    mpuIntStatus = mpu.getIntStatus();

    // set our DMP Ready flag so the main loop() function knows it's okay to use it
    printf("DMP ready!\n");
    dmpReady = true;
 
    // get expected DMP packet size for later comparison
    packetSize = mpu.dmpGetFIFOPacketSize();

    return true;
  } else {
    // ERROR!
    // 1 = initial memory load failed
    // 2 = DMP configuration updates failed
    // (if it's going to break, usually the code will be 1)
    printf("DMP Initialization failed (code %d)\n", devStatus);
    return false;
  }
}

void *readFromFIFO(void *ypr_void_ptr) {
  float *ypr_ptr = (float *)ypr_void_ptr;
  float rotation[3] = {0};
  float last_ypr[3] = {0};
  
  int16_t ax, ay, az;
  int16_t gx, gy, gz;

  high_resolution_clock::time_point last_read = high_resolution_clock::now();
  high_resolution_clock::time_point current_read; 
 
  for (;;) {
    // Reading only raw values
    if(raw_initialized){
      mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

      ypr_ptr[0] = (float)gx;
      ypr_ptr[1] = (float)gy;
      ypr_ptr[2] = (float)gz;
      ypr_ptr[3] = (float)ax;
      ypr_ptr[4] = (float)ay;
      ypr_ptr[5] = (float)az;
    }
    else
    {
      // if programming failed, don't try to do anything
      if (!dmpReady) return NULL;

      // Reading values from mpu
      if (mpu.dmpPacketAvailable()) {
        // read a packet from FIFO
        mpu.getFIFOBytes(fifoBuffer, packetSize);

        // display Euler angles in degrees
        mpu.dmpGetQuaternion(&q, fifoBuffer);
        mpu.dmpGetGravity(&gravity, &q);
        mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);

        ypr_ptr[0] = ypr[0] * 180/M_PI;
        ypr_ptr[1] = ypr[1] * 180/M_PI;
        ypr_ptr[2] = ypr[2] * 180/M_PI;

        // calcuate rotation
        current_read = high_resolution_clock::now();
        duration<double> delta = duration_cast<duration<double>>(current_read - last_read);

        rotation[0] = (ypr_ptr[0] - last_ypr[0]) / (float)delta.count();	
        rotation[1] = (ypr_ptr[1] - last_ypr[1]) / (float)delta.count();
        rotation[2] = (ypr_ptr[2] - last_ypr[2]) / (float)delta.count();

        ypr_ptr[3] = rotation[0];
        ypr_ptr[4] = rotation[1];
        ypr_ptr[5] = rotation[2];

        last_read = current_read;
        last_ypr[0] = ypr_ptr[0];
        last_ypr[1] = ypr_ptr[1];
        last_ypr[2] = ypr_ptr[2];

        mpu.resetFIFO();
      }
    }

    usleep(1000);
  }

  return NULL;
}

high_resolution_clock::time_point since = high_resolution_clock::now();

bool initCalibration() {
  // Variables
  int16_t ax = 0, ay = 0, az = 0;
  int16_t gx = 0, gy = 0, gz = 0;

  int16_t l_ax = 0, l_ay = 0, l_az = 0;
  int16_t l_gx = 0, l_gy = 0, l_gz = 0;

  float mean_ax = 0, mean_ay = 0, mean_az = 0;
  float mean_gx = 0, mean_gy = 0, mean_gz = 0;

  int sum_ax = 0, sum_ay= 0, sum_az= 0;
  int sum_gx= 0, sum_gy= 0, sum_gz= 0;

  bool rax = false, ray= false, raz= false;
  bool rgx= false, rgy= false, rgz= false;

  auto control = high_resolution_clock::now();

  mpu.initialize();

  mpu.setXAccelOffset(0);
  mpu.setYAccelOffset(0);
  mpu.setZAccelOffset(0);
  mpu.setXGyroOffset(0);
  mpu.setYGyroOffset(0);
  mpu.setZGyroOffset(0);

  bool calibrated = false;
  auto count = 0;

  printf("Calibration started, waiting for 180 seconds for sensor stabilization.\n");

  while(!calibrated){
    
    usleep(2000);

    // ypr = zyx
    mpu.getRotation(&gx, &gy, &gz);
    mpu.getAcceleration(&ax, &ay, &az);

    auto delta_time = duration_cast<nanoseconds>(high_resolution_clock::now() - since);

    if(delta_time.count() > 240e9){
      printf("Calibration failed.\n");
      return false;
    }

    if (delta_time.count() > 10e9) {
      if(l_ax == ax && l_ay == ay && l_az == az && 
         l_gx == gx && l_gy == gy && l_gz == gz)
      {
        continue;
      }

      l_ax = ax; l_ay = ay; l_az = az;
      l_gx = gx; l_gy = gy; l_gz = gz;

      if (rax && ray && raz && rgx && rgy && rgz )
      {
        printf("Calibrated Data:\n");
        printf("mean: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
        printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
        printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);

        std::ofstream out("calibration.txt");
        out << off_ax << "\n" << off_ay << "\n" << off_az << "\n" << off_gx << "\n" << off_gy << "\n" << off_gz;
        out.close();

        return true;
      }

      if(count > 1000){
        count = 0;

        sum_ax = 0; sum_ay = 0; sum_az = 0;
        sum_gx = 0; sum_gy = 0; sum_gz = 0;
      }

      count++;

      sum_ax = sum_ax + ax; sum_ay = sum_ay + ay; sum_az = sum_az + az;
      sum_gx = sum_gx + gx; sum_gy = sum_gy + gy; sum_gz = sum_gz + gz;

      mean_ax = (float)(sum_ax / count); mean_ay = (float)(sum_ay / count); mean_az = (float)(sum_az / count);
      mean_gx = (float)(sum_gx / count); mean_gy = (float)(sum_gy / count); mean_gz = (float)(sum_gz / count);

      auto a_Deadzone = 1;
      auto g_Deadzone = 1;

      if (!rax && mean_ax >   0   + a_Deadzone) off_ax--; else if (!rax && mean_ax <   0   - a_Deadzone) off_ax++; else rax = true;
      if (!ray && mean_ay >   0   + a_Deadzone) off_ay--; else if (!ray && mean_ay <   0   - a_Deadzone) off_ay++; else ray = true;
      if (!raz && mean_az > 16384 + a_Deadzone) off_az--; else if (!raz && mean_az < 16384 - a_Deadzone) off_az++; else raz = true;
      
      if (!rgx && mean_gx > g_Deadzone) off_gx--; else if (!rgx && mean_gx < -g_Deadzone) off_gx++; else rgx = true;
      if (!rgy && mean_gy > g_Deadzone) off_gy--; else if (!rgy && mean_gy < -g_Deadzone) off_gy++; else rgy = true;
      if (!rgz && mean_gz > g_Deadzone) off_gz--; else if (!rgz && mean_gz < -g_Deadzone) off_gz++; else rgz = true;
      
      mpu.setXAccelOffset(off_ax);
      mpu.setYAccelOffset(off_ay);
      mpu.setZAccelOffset(off_az);
      mpu.setXGyroOffset(off_gx);
      mpu.setYGyroOffset(off_gy);
      mpu.setZGyroOffset(off_gz);
        
      if(duration_cast<nanoseconds>(high_resolution_clock::now() - control).count() > 1e9){
        control = high_resolution_clock::now();
        printf("mean: ax:%f ay:%f az:%f gx:%f gy:%f gz:%f\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
        printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
        printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);
      }
    }
  }
  return false;
}

NAN_MODULE_INIT(InitAll) {
  Nan::Set(target, Nan::New("getAttitude").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(GetAttitude)).ToLocalChecked());

  Nan::Set(target, Nan::New("getRotation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(GetRotation)).ToLocalChecked());

  Nan::Set(target, Nan::New("getRawMotion6").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(GetRawMotion6)).ToLocalChecked());

  Nan::Set(target, Nan::New("initialize").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(Initialize)).ToLocalChecked());

  Nan::Set(target, Nan::New("initializeRaw").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(InitializeRaw)).ToLocalChecked());

  Nan::Set(target, Nan::New("calibrate").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(Calibrate)).ToLocalChecked());
}

NODE_MODULE(binding, InitAll)
