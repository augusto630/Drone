#include "binding.h"
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <string>

using v8::FunctionTemplate;
using namespace std::chrono;

NAN_METHOD(GetAttitude) {
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  Nan::Set(obj, Nan::New("yaw").ToLocalChecked(), Nan::New(data_out[0]));
  Nan::Set(obj, Nan::New("pitch").ToLocalChecked(), Nan::New(data_out[1]));
  Nan::Set(obj, Nan::New("roll").ToLocalChecked(), Nan::New(data_out[2]));
  info.GetReturnValue().Set(obj);
}

NAN_METHOD(GetRotation) {
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  Nan::Set(obj, Nan::New("yaw").ToLocalChecked(), Nan::New(data_out[3]));
  Nan::Set(obj, Nan::New("pitch").ToLocalChecked(), Nan::New(data_out[4]));
  Nan::Set(obj, Nan::New("roll").ToLocalChecked(), Nan::New(data_out[5]));
  info.GetReturnValue().Set(obj);
}

NAN_METHOD(Calibrate) {
  if(initCalibration()){
    info.GetReturnValue().Set(true);
  }else{
    info.GetReturnValue().Set(false);
  }
}

NAN_METHOD(Initialize) {
  if (!initMPU()) {
    info.GetReturnValue().Set(false);
    return;
  }

  if (pthread_create(&readThread, NULL, readFromFIFO, &data_out)) {
    fprintf(stderr, "Error creating thread\n");
    info.GetReturnValue().Set(false);
  } else {
    info.GetReturnValue().Set(true);
  }
}

int16_t off_ax = 0, off_ay= 0, off_az= 0;
int16_t off_gx = 0, off_gy= 0, off_gz= 0;

bool initMPU() {
  // initialize device
  printf("Initializing I2C devices...\n");
  mpu.initialize();

  printf("Setting calibration...\n");

  std::ifstream in("calibration.txt");
  in >> off_ax >> off_ay >> off_az >> off_gx >> off_gy >> off_gz;
  in.close();

  printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);

  // myfile.open ("calibration.txt", std::ios::out);
  // if(myfile.is_open()){
    
  //   std::string s_off_ax = "", s_off_ay= "", s_off_az= "";
  //   std::string s_off_gx = "", s_off_gy= "", s_off_gz= "";

  //   std::getline(myfile, s_off_ax);
  //   std::getline(myfile, s_off_ax);
  //   std::getline(myfile, s_off_ay);
  //   std::getline(myfile, s_off_az);
  //   std::getline(myfile, s_off_gx);
  //   std::getline(myfile, s_off_gy);
  //   std::getline(myfile, s_off_gz);

  //   off_ax = std::stoi(s_off_ax);
  //   off_ax = std::stoi(s_off_ax);
  //   off_ay = std::stoi(s_off_ay);
  //   off_az = std::stoi(s_off_az);
  //   off_gx = std::stoi(s_off_gx);
  //   off_gy = std::stoi(s_off_gy);
  //   off_gz = std::stoi(s_off_gz);

  //   myfile.close();
  // }

  // verify connection
  printf("Testing device connections...\n");
  printf(mpu.testConnection() ? "MPU6050 connection successful\n" : "MPU6050 connection failed\n");

  printf("Initializing DMP...\n");
  devStatus = mpu.dmpInitialize();

  // make sure it worked (returns 0 if so)
  if (devStatus == 0) {

    mpu.setXAccelOffset(off_ax);
    mpu.setYAccelOffset(off_ay);
    mpu.setZAccelOffset(off_az);
    mpu.setXGyroOffset(off_gx);
    mpu.setYGyroOffset(off_gy);
    mpu.setZGyroOffset(off_gz);

    // turn on the DMP, now that it's ready
    printf("Enabling DMP...\n");
    mpu.setDMPEnabled(true);

    mpuIntStatus = mpu.getIntStatus();

    // set our DMP Ready flag so the main loop() function knows it's okay to use it
    printf("DMP ready!\n");
    dmpReady = true;
 
    // get expected DMP packet size for later comparison
    packetSize = mpu.dmpGetFIFOPacketSize();

    return true;
  } else {
    // ERROR!
    // 1 = initial memory load failed
    // 2 = DMP configuration updates failed
    // (if it's going to break, usually the code will be 1)
    printf("DMP Initialization failed (code %d)\n", devStatus);
    return false;
  }
}

void *readFromFIFO(void *ypr_void_ptr) {
  float *ypr_ptr = (float *)ypr_void_ptr;
  float rotation[3] = {0};
  float last_ypr[3] = {0};

  high_resolution_clock::time_point last_read = high_resolution_clock::now();
  high_resolution_clock::time_point current_read; 
 
  for (;;) {
    // if programming failed, don't try to do anything
    if (!dmpReady) return NULL;

    // get current FIFO count
    fifoCount = mpu.getFIFOCount();

    if (fifoCount == 1024) {
        // reset so we can continue cleanly
        mpu.resetFIFO();
        printf("FIFO overflow!\n");

    // otherwise, check for DMP data ready interrupt (this should happen frequently)
    } else if (fifoCount >= 42) {
      // read a packet from FIFO
      mpu.getFIFOBytes(fifoBuffer, packetSize);

      // display Euler angles in degrees
      mpu.dmpGetQuaternion(&q, fifoBuffer);
      mpu.dmpGetGravity(&gravity, &q);
      mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);

      ypr_ptr[0] = ypr[0] * 180/M_PI;
      ypr_ptr[1] = ypr[1] * 180/M_PI;
      ypr_ptr[2] = ypr[2] * 180/M_PI;

      // calcuate rotation
      current_read = high_resolution_clock::now();
      duration<double> delta = duration_cast<duration<double>>(current_read - last_read);

      rotation[0] = (ypr_ptr[0] - last_ypr[0]) / (float)delta.count();	
      rotation[1] = (ypr_ptr[1] - last_ypr[1]) / (float)delta.count();
      rotation[2] = (ypr_ptr[2] - last_ypr[2]) / (float)delta.count();

      ypr_ptr[3] = rotation[0];
      ypr_ptr[4] = rotation[1];
      ypr_ptr[5] = rotation[2];

      last_read = current_read;
      last_ypr[0] = ypr_ptr[0];
      last_ypr[1] = ypr_ptr[1];
      last_ypr[2] = ypr_ptr[2];

      mpu.resetFIFO();
    }
  }

  return NULL;
}

high_resolution_clock::time_point since = high_resolution_clock::now();

bool initCalibration() {
  // Variables
  int16_t ax, ay, az;
  int16_t gx, gy, gz;

  int16_t mean_ax = 10, mean_ay = 10, mean_az = 10;
  int16_t mean_gx = 2, mean_gy = 2, mean_gz = 2;

  int sum_ax = 0, sum_ay= 0, sum_az= 0;
  int sum_gx= 0, sum_gy= 0, sum_gz= 0;

  bool rax = false, ray= false, raz= false;
  bool rgx= false, rgy= false, rgz= false;

  auto control = high_resolution_clock::now();

  mpu.initialize();

  mpu.setXAccelOffset(0);
  mpu.setYAccelOffset(0);
  mpu.setZAccelOffset(0);
  mpu.setXGyroOffset(0);
  mpu.setYGyroOffset(0);
  mpu.setZGyroOffset(0);

  bool calibrated = false;
  auto count = 0;

  printf("Calibration started, waiting for 180 seconds for sensor stabilization.\n");

  while(!calibrated){

    // ypr = zyx
    mpu.getRotation(&gx, &gy, &gz);
    mpu.getAcceleration(&ax, &ay, &az);

    //printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
    //printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);

    auto delta_time = duration_cast<nanoseconds>(high_resolution_clock::now() - since);

    if(delta_time.count() > 240e9){
      printf("Calibration failed.\n");
      return false;
    }

    if (delta_time.count() > 120e9) {
      if (rax && ray && raz && rgx && rgy && rgz )
      {
        printf("Calibrated Data:\n");
        printf("mean: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
        printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
        printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);

        std::ofstream out("calibration.txt");
        out << off_ax << "\n" << off_ay << "\n" << off_az << "\n" << off_gx << "\n" << off_gy << "\n" << off_gz;
        out.close();

        return true;
        
        // std::fstream myfile;
        // myfile.open ("calibration.txt", std::ios::out|std::ios::trunc);
        // if(myfile.is_open()){
        //   printf("Calibration file created.");
        //   myfile << off_ax << "\n";
        //   myfile << off_ay << "\n";
        //   myfile << off_az << "\n";
        //   myfile << off_gx << "\n";
        //   myfile << off_gy << "\n";
        //   myfile << off_gz << "\n";
        //   myfile.close();

        //   return true;
        // }else{
        //   printf("Failed writing calibration file.");
        //   return false;
        // }
      }

      count++;

      sum_ax = sum_ax + ax;
      sum_ay = sum_ay + ay;
      sum_az = sum_az + az;

      sum_gx = sum_gx + gx;
      sum_gy = sum_gy + gy;
      sum_gz = sum_gz + gz;

      mean_ax = ((sum_ax / count) + mean_ax) / 2;
      mean_ay = ((sum_ay / count) + mean_ay) / 2;
      mean_az = ((sum_az / count) + mean_az) / 2;

      mean_gx = ((sum_gx / count) + mean_gx) / 2;
      mean_gy = ((sum_gy / count) + mean_gy) / 2;
      mean_gz = ((sum_gz / count) + mean_gz) / 2;

      if(count > 1000){
        count = 0;
        sum_ax = 0;
        sum_ay = 0;
        sum_az = 0;

        sum_gx = 0;
        sum_gy = 0;
        sum_gz = 0;
      }

      auto a_Deadzone = 8;
      auto g_Deadzone = 1;

      if (!rax && ax >   0   + a_Deadzone) off_ax--; else if (!rax && ax <   0   - a_Deadzone) off_ax++; else rax = true;
      if (!ray && ay >   0   + a_Deadzone) off_ay--; else if (!ray && ay <   0   - a_Deadzone) off_ay++; else ray = true;
      if (!raz && az > 16384 + a_Deadzone) off_az--; else if (!raz && az < 16384 - a_Deadzone) off_az++; else raz = true;
      
      if (!rgx && gx > g_Deadzone) off_gx++; else if (!rgx && gx < -g_Deadzone) off_gx--; else rgx = true;
      if (!rgy && gy > g_Deadzone) off_gy++; else if (!rgy && gy < -g_Deadzone) off_gy--; else rgy = true;
      if (!rgz && gz > g_Deadzone) off_gz++; else if (!rgz && gz < -g_Deadzone) off_gz--; else rgz = true;
      
      mpu.setXAccelOffset(off_ax);
      mpu.setYAccelOffset(off_ay);
      mpu.setZAccelOffset(off_az);
      mpu.setXGyroOffset(off_gx);
      mpu.setYGyroOffset(off_gy);
      mpu.setZGyroOffset(off_gz);
        
      if(duration_cast<nanoseconds>(high_resolution_clock::now() - control).count() > 1e9){
        control = high_resolution_clock::now();
        printf("mean: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
        printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
        printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);
      }
    }
  }
  return false;
}

NAN_MODULE_INIT(InitAll) {
  Nan::Set(target, Nan::New("getAttitude").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(GetAttitude)).ToLocalChecked());
  Nan::Set(target, Nan::New("getRotation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(GetRotation)).ToLocalChecked());
  Nan::Set(target, Nan::New("initialize").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(Initialize)).ToLocalChecked());
  Nan::Set(target, Nan::New("calibrate").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(Calibrate)).ToLocalChecked());
}

NODE_MODULE(binding, InitAll)
