#include "binding.h"
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <string>

using v8::FunctionTemplate;
using namespace std::chrono;

NAN_METHOD(GetAttitude) {
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  Nan::Set(obj, Nan::New("yaw").ToLocalChecked(), Nan::New(data_out[0]));
  Nan::Set(obj, Nan::New("pitch").ToLocalChecked(), Nan::New(data_out[1]));
  Nan::Set(obj, Nan::New("roll").ToLocalChecked(), Nan::New(data_out[2]));
  info.GetReturnValue().Set(obj);
}

NAN_METHOD(GetRotation) {
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  Nan::Set(obj, Nan::New("yaw").ToLocalChecked(), Nan::New(data_out[3]));
  Nan::Set(obj, Nan::New("pitch").ToLocalChecked(), Nan::New(data_out[4]));
  Nan::Set(obj, Nan::New("roll").ToLocalChecked(), Nan::New(data_out[5]));
  info.GetReturnValue().Set(obj);
}

int16_t ax, ay, az;
int16_t gx, gy, gz;

NAN_METHOD(GetRawMotion6) {
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();

  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

  Nan::Set(obj, Nan::New("gyro_x").ToLocalChecked(), Nan::New((float)gx));
  Nan::Set(obj, Nan::New("gyro_y").ToLocalChecked(), Nan::New((float)gy));
  Nan::Set(obj, Nan::New("gyro_z").ToLocalChecked(), Nan::New((float)gz));
  Nan::Set(obj, Nan::New("accel_x").ToLocalChecked(), Nan::New((float)ax));
  Nan::Set(obj, Nan::New("accel_y").ToLocalChecked(), Nan::New((float)ay));
  Nan::Set(obj, Nan::New("accel_z").ToLocalChecked(), Nan::New((float)az));

  info.GetReturnValue().Set(obj);
}

NAN_METHOD(Initialize) {
  raw_initialized = false;
  if (pthread_create(&readThread, NULL, readFromFIFO, &data_out)) {
    fprintf(stderr, "Error creating thread\n");
    info.GetReturnValue().Set(false);
  } else {

    if (!initMPU()) {
      info.GetReturnValue().Set(false);
      return;
    }

    info.GetReturnValue().Set(true);
  }
}

NAN_METHOD(InitializeRaw) {
  raw_initialized = true;

  // if (pthread_create(&readThread, NULL, readFromFIFO, &data_out)) {
  //   fprintf(stderr, "Error creating thread\n");
  //   info.GetReturnValue().Set(false);
  // } else {

  if (!initMPU()) {
    info.GetReturnValue().Set(false);
    return;
  }

  info.GetReturnValue().Set(true);
}

NAN_METHOD(Calibrate) {
  if(initCalibration()){
    info.GetReturnValue().Set(true);
  }else{
    info.GetReturnValue().Set(false);
  }
}

int16_t off_ax = 0, off_ay= 0, off_az= 0;
int16_t off_gx = 0, off_gy= 0, off_gz= 0;

bool initMPU() {
  // initialize device
  printf("Initializing I2C devices...\n");
  mpu.initialize();

  printf("Setting calibration...\n");

  std::ifstream in("calibration.txt");
  in >> off_ax >> off_ay >> off_az >> off_gx >> off_gy >> off_gz;
  in.close();

  printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);

  // verify connection
  printf("Testing device connections...\n");
  printf(mpu.testConnection() ? "MPU6050 connection successful\n" : "MPU6050 connection failed\n");

  if(!raw_initialized){
    printf("Initializing DMP...\n");
    devStatus = mpu.dmpInitialize();

    // printf("Initialized at fifo rate of: %d.\n", mpu.dmpGetFIFORate());
    // printf("Initialized at sample frequency of: %d.\n", mpu.dmpGetSampleFrequency());
  }

  mpu.setXAccelOffset(off_ax);
  mpu.setYAccelOffset(off_ay);
  mpu.setZAccelOffset(off_az);
  mpu.setXGyroOffset(off_gx);
  mpu.setYGyroOffset(off_gy);
  mpu.setZGyroOffset(off_gz);

  // make sure it worked (returns 0 if so)
  if (devStatus == 0) {   

    // If raw, ignore dmp
    if(raw_initialized){
      return true;
    }

    // turn on the DMP, now that it's ready
    printf("Enabling DMP...\n");
    mpu.setDMPEnabled(true);

    mpuIntStatus = mpu.getIntStatus();

    // set our DMP Ready flag so the main loop() function knows it's okay to use it
    printf("DMP ready!\n");
    dmpReady = true;
 
    // get expected DMP packet size for later comparison
    packetSize = mpu.dmpGetFIFOPacketSize();

    return true;
  } else {
    // ERROR!
    // 1 = initial memory load failed
    // 2 = DMP configuration updates failed
    // (if it's going to break, usually the code will be 1)
    printf("DMP Initialization failed (code %d)\n", devStatus);
    return false;
  }
}

void *readFromFIFO(void *ypr_void_ptr) {
  float *ypr_ptr = (float *)ypr_void_ptr;
  float rotation[3] = {0};
  float last_ypr[3] = {0};
  
  int16_t ax, ay, az;
  int16_t gx, gy, gz;
  uint16_t fifoCount;

  high_resolution_clock::time_point last_read = high_resolution_clock::now();
  high_resolution_clock::time_point current_read; 
 
  for (;;) {
    // Reading only raw values
    if(raw_initialized){
      mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

      ypr_ptr[0] = (float)gx;
      ypr_ptr[1] = (float)gy;
      ypr_ptr[2] = (float)gz;
      ypr_ptr[3] = (float)ax;
      ypr_ptr[4] = (float)ay;
      ypr_ptr[5] = (float)az;
    }
    else
    {
      // if programming failed, don't try to do anything
      if (!dmpReady){
        usleep(150);
        continue; 
      }
      
      fifoCount = mpu.getFIFOCount();
      if (fifoCount % packetSize != 0) {
            mpu.resetFIFO();
      }
      // Reading values from mpu
      else if (fifoCount > packetSize) {
        // read a packet from FIFO
        mpu.getFIFOBytes(fifoBuffer, packetSize);

        // display Euler angles in degrees
        mpu.dmpGetQuaternion(&q, fifoBuffer);
        mpu.dmpGetGravity(&gravity, &q);
        mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);

        ypr_ptr[0] = ypr[0] * 180/M_PI;
        ypr_ptr[1] = ypr[1] * 180/M_PI;
        ypr_ptr[2] = ypr[2] * 180/M_PI;

        // calcuate rotation
        current_read = high_resolution_clock::now();
        duration<double> delta = duration_cast<duration<double>>(current_read - last_read);

        rotation[0] = (ypr_ptr[0] - last_ypr[0]) / (float)delta.count();	
        rotation[1] = (ypr_ptr[1] - last_ypr[1]) / (float)delta.count();
        rotation[2] = (ypr_ptr[2] - last_ypr[2]) / (float)delta.count();

        ypr_ptr[3] = rotation[0];
        ypr_ptr[4] = rotation[1];
        ypr_ptr[5] = rotation[2];

        last_read = current_read;
        last_ypr[0] = ypr_ptr[0];
        last_ypr[1] = ypr_ptr[1];
        last_ypr[2] = ypr_ptr[2];
      }
    }

    usleep(150);
  }

  return NULL;
}

high_resolution_clock::time_point since = high_resolution_clock::now();

bool initCalibration() {
  // Variables
  int16_t ax = 0, ay = 0, az = 0;
  int16_t gx = 0, gy = 0, gz = 0;

  int16_t l_ax = 0, l_ay = 0, l_az = 0;
  int16_t l_gx = 0, l_gy = 0, l_gz = 0;

  float mean_ax = 0, mean_ay = 0, mean_az = 0;
  float mean_gx = 0, mean_gy = 0, mean_gz = 0;

  int sum_ax = 0, sum_ay= 0, sum_az= 0;
  int sum_gx= 0, sum_gy= 0, sum_gz= 0;

  int rax = 0, ray = 0, raz= 0;
  int rgx = 0, rgy = 0, rgz= 0;

  auto control = high_resolution_clock::now();
  auto control_2 = high_resolution_clock::now();
  auto control_3 = high_resolution_clock::now();

  mpu.initialize();

  mpu.setXAccelOffset(0);
  mpu.setYAccelOffset(0);
  mpu.setZAccelOffset(0);
  mpu.setXGyroOffset(0);
  mpu.setYGyroOffset(0);
  mpu.setZGyroOffset(0);

  bool calibrated = false;
  auto count_a = 0;
  auto count_g = 0;
  auto tries = 300;
  auto a_Deadzone = 1;
  auto g_Deadzone = 1;

  printf("Calibration started, waiting for 180 seconds for sensor stabilization.\n");

  while(!calibrated){
    
    usleep(500);

    // ypr = zyx
    mpu.getRotation(&gx, &gy, &gz);
    mpu.getAcceleration(&ax, &ay, &az);

    auto delta_time = duration_cast<nanoseconds>(high_resolution_clock::now() - since);

    if(delta_time.count() > 1800e9){
      printf("Calibration failed.\n");
      return false;
    }

    if (delta_time.count() > 10e9) {
      if(l_ax == ax && l_ay == ay && l_az == az && 
         l_gx == gx && l_gy == gy && l_gz == gz)
      {
        continue;
      }

      l_ax = ax; l_ay = ay; l_az = az;
      l_gx = gx; l_gy = gy; l_gz = gz;

      if (rax > tries && ray > tries && raz > tries && rgx > tries && rgy > tries && rgz > tries)
      {
        printf("Calibrated Data:\n");
        printf("mean: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
        printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
        printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);

        std::ofstream out("calibration.txt");
        out << off_ax << "\n" << off_ay << "\n" << off_az << "\n" << off_gx << "\n" << off_gy << "\n" << off_gz;
        out.close();

        return true;
      }

      // if(count > 10000){
      //   count = 0;

      //   sum_ax = ax; sum_ay = ay; sum_az = az;
      //   sum_gx = gx; sum_gy = gy; sum_gz = gz;
      // }

      // if(ax < a_Deadzone && ax > -a_Deadzone){
      //   sum_ax = 50;
      // }

      // if(ay < a_Deadzone && ay > -a_Deadzone){
      //   sum_ay = 50;
      // }

      // if(az < 16384 + a_Deadzone && az > 16384 - a_Deadzone){
      //   sum_az = 16400;
      // }

      if(gx < g_Deadzone && gx > -g_Deadzone){
        sum_gx = 5;
      }

      if(gy < g_Deadzone && gy > -g_Deadzone){
        sum_gy = 5;
      }

      if(gz < g_Deadzone && gz > -g_Deadzone){
        sum_gz = 5;
      }

      count_a++;
      count_g++;

      sum_ax = sum_ax + ax; sum_ay = sum_ay + ay; sum_az = sum_az + az;
      sum_gx = sum_gx + gx; sum_gy = sum_gy + gy; sum_gz = sum_gz + gz;

      mean_ax = (float)(sum_ax / count_a); mean_ay = (float)(sum_ay / count_a); mean_az = (float)(sum_az / count_a);
      mean_gx = (float)(sum_gx / count_g); mean_gy = (float)(sum_gy / count_g); mean_gz = (float)(sum_gz / count_g);

      if(duration_cast<nanoseconds>(high_resolution_clock::now() - control_2).count() > 0.2e9)
      {
        control_2 = high_resolution_clock::now();
        if (rax < tries && mean_ax > a_Deadzone) off_ax--; 
        else if (rax < tries && mean_ax < -a_Deadzone) off_ax++; 
        else{
          // printf("Rax Found!");
          // printf("mean: ax:%f ay:%f az:%f gx:%f gy:%f gz:%f\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
          // printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
          // printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);  
          rax++;
        }

        if (ray < tries  && mean_ay >   0   + a_Deadzone) off_ay--; else if (ray < tries && mean_ay <   0   - a_Deadzone) off_ay++;
        else{
          // printf("Ray Found!");
          // printf("mean: ax:%f ay:%f az:%f gx:%f gy:%f gz:%f\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
          // printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
          // printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);
          
          ray++;
        }

        if (raz < tries  && mean_az > 16384 + a_Deadzone) off_az--; else if (raz < tries && mean_az < 16384 - a_Deadzone) off_az++;
        else{
          // printf("Raz Found!");
          // printf("mean: ax:%f ay:%f az:%f gx:%f gy:%f gz:%f\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
          // printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
          // printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);
          
          raz++;
        }
        
        if (rgx < tries  && mean_gx > g_Deadzone) off_gx--; else if (rgx < tries && mean_gx < -g_Deadzone) off_gx++;
        else{
          // printf("Rgx Found!");
          // printf("mean: ax:%f ay:%f az:%f gx:%f gy:%f gz:%f\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
          // printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
          // printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);
          
          rgx++;
        }

        if (rgy < tries && mean_gy > g_Deadzone) off_gy--; else if (rgy < tries && mean_gy < -g_Deadzone) off_gy++;
        else{
          // printf("Rgy Found!");
          // printf("mean: ax:%f ay:%f az:%f gx:%f gy:%f gz:%f\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
          // printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
          // printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);
          rgy++;
        }
        
        if (rgz < tries  && mean_gz > g_Deadzone) off_gz--; else if (rgz < tries && mean_gz < -g_Deadzone) off_gz++;
        else{
          // printf("Rgz Found!");
          // printf("mean: ax:%f ay:%f az:%f gx:%f gy:%f gz:%f\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
          // printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
          // printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);
          rgz++;
        }
      }

      if(duration_cast<nanoseconds>(high_resolution_clock::now() - control_3).count() > 20e9)
      {
        control_3 = high_resolution_clock::now();
        sum_ax = ax;
        sum_ay = ay;
        sum_az = az;
        count_a = 1;
      }
      
      mpu.setXAccelOffset(off_ax);
      mpu.setYAccelOffset(off_ay);
      mpu.setZAccelOffset(off_az);
      mpu.setXGyroOffset(off_gx);
      mpu.setYGyroOffset(off_gy);
      mpu.setZGyroOffset(off_gz);
        
      if(duration_cast<nanoseconds>(high_resolution_clock::now() - control).count() > 1e9){
        control = high_resolution_clock::now();
        printf("mean: ax:%f ay:%f az:%f gx:%f gy:%f gz:%f\n", mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz);
        printf("offsets: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", off_ax, off_ay, off_az, off_gx, off_gy, off_gz);
        printf("values: ax:%d ay:%d az:%d gx:%d gy:%d gz:%d\n", ax, ay, az, gx, gy, gz);
      }
    }
  }
  return false;
}

NAN_MODULE_INIT(InitAll) {
  Nan::Set(target, Nan::New("getAttitude").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(GetAttitude)).ToLocalChecked());

  Nan::Set(target, Nan::New("getRotation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(GetRotation)).ToLocalChecked());

  Nan::Set(target, Nan::New("getRawMotion6").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(GetRawMotion6)).ToLocalChecked());

  Nan::Set(target, Nan::New("initialize").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(Initialize)).ToLocalChecked());

  Nan::Set(target, Nan::New("initializeRaw").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(InitializeRaw)).ToLocalChecked());

  Nan::Set(target, Nan::New("calibrate").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(Calibrate)).ToLocalChecked());
}

NODE_MODULE(binding, InitAll)
